**Московский Авиационный Институт**

**(Национально Исследовательский Университет)**

**Факультет информационных технологий и прикладной**

**математики**

**Курсовая работа по курсу**

**«Вычислительные системы»**

**Первый семестр**

**Задание 4**

«Процедуры и функции в качестве параметров»

Студент: Боев Савелий Сергеевич

Группа: М8О-107Б-21

Преподаватель: Найдёнов И.Е.

Оценка:

Дата: 08.01.2022

# **Оглавление**

[**Цель работы**](#цель-работы)

[**Общий метод решения**](#общий-метод-решения)

[**Краткие сведения из численных методов**](#краткие-сведения-из-численных-методов)

[**Использованные функции и переменные**](#использованные-функции-и-переменные)

[**Код программы**](#код-программы)

[**Протокол**](#протокол)

[**Вывод**](#вывод)

# **Цель работы**

Составить программу на языке Си с процедурами решения трансцедентных алгебраических уравнений различными численными методам (итераций, Ньютона и половинного деление — дихотомии). Уравнения оформить как функции параметры, разрешив относительно неизвестной величины в случае необходимости. Применить каждую процедуру к решению уравнения — заданного вариантом. Если метод неприменим, дать математическое обоснование и графическую иллюстрацию, например, с использованием Гнуплота.

**Вариант №4**

**Уравнение:**

![](https://i.imgur.com/asHCjSS.gif)

**Отрезок содержащий корень: [1,3]**

**Базовый метод: Ньютона**

**Приближенное значение корня: 2.0692**

# **Общий метод решения**

Необходимо описать возможностями языка Си вычисление приближенного значения функции методом итерации, дихотомии (половинного деления), Ньютона. Далее подставить в значения переменных функцию, вывести полученные значения и сравнить с приближенными значениями x.

# **Краткие сведения из численных методов**

![](https://i.imgur.com/tjpPfVA.gif)

# **Использованные функции и переменные**

| e | Машинный эпсилон |
| --- | --- |
| Right, a | Правая граница |
| Left, b | Левая граница |
| X0 | Среднее значение суммы |

**Функция вычисления метода дихитомии**

```
double delh(double f(double), double left, double right, double e0)
{
    double x0;
    while (right - left > e0 + 0.00001) {
        x0 = (left + right) / 2.0;
        if (f(x0)*f(left) < 0) {
            right = x0;
        } else {
            left = x0;
        }
    }
    return x0;
}
```

**Функция вычисления методом итераций**

```
double iter(double f(double), double x0, double e0)
{
    double left = x0;
    double right = left + 1;
    while (fabs(left - right) > e0 + 0.00001) {
        right = left;
        left = f(right);
    }
    return left;
}
```

**Функция вычисления методом Ньютона**
```
double newton(double f(double), double derivative(double), double x0, double e0)
{
    double left = x0;
    double right = left + 1;
    while (fabs(left - right) > e0 + 0.00001) {
        right = left;
        left = right - (f(right) / derivative(right));
    }
    return left;
}
```

**Функция для получения метода итерации**

```
double squeeze(double x) {
    return x - (f(x) / derivative((1.0 + 3.0) / 2));
}
```

# **Код программы**
```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double machine_epsilon(void)
{
    double e = 1.0;
    while (1.0 + e / 2.0 > 1.0) {
        e /= 2.0;
    }
    return e;
}

double f(double x) {
    return 3*x-14+exp(x)-exp(-x);
}

double derivative(double x) {
    return 3+exp(x)+exp(-x);
}

double squeeze(double x) {
    return x - (f(x) / derivative((1.0 + 3.0) / 2));
}

double delh(double f(double), double left, double right, double e0)
{
    double x0;
    while (right - left > e0 + 0.00001) {
        x0 = (left + right) / 2.0;
        if (f(x0)*f(left) < 0) {
            right = x0;
        } else {
            left = x0;
        }
    }
    return x0;
}

double iter(double f(double), double x0, double e0)
{
    double left = x0;
    double right = left + 1;
    while (fabs(left - right) > e0 + 0.00001) {
        right = left;
        left = f(right);
    }
    return left;
}

double newton(double f(double), double derivative(double), double x0, double e0)
{
    double left = x0;
    double right = left + 1;
    while (fabs(left - right) > e0 + 0.00001) {
        right = left;
        left = right - (f(right) / derivative(right));
    }
    return left;
}

int main(void)
{
    double e0 = machine_epsilon();
    printf("Machine epsilon for double: %.8e\n\n", e0);
    double a=1.0;
    double b=3.0;
    double x0;
    printf(" ------------------------------------------ \n");
    printf("| 3*x-14+exp(x)-exp(-x) = 0 |\n");
    printf(" ------------------------------------------ \n");
    printf("|method | answer |\n");
    printf(" ------------------------------------------ \n");
    x0 = delh(f, a, b, e0);
    printf("|dichotomy | %.16f |\n",x0);
    x0 = iter (squeeze, (a + b) / 2.0, e0);
    printf("|iteration | %.16f |\n",x0);
    x0 = newton(f, derivative, (a + b) / 2.0, e0);
    printf("|newton | %.16f |\n",x0);
    printf(" ------------------------------------------ \n\n");
    return 0;
}
```
# **Протокол**

```
Machine epsilon for double: 2.22044605e-16

 ------------------------------------------ 
|        3*x-14+exp(x)-exp(-x) = 0        |
 ------------------------------------------ 
|     method     |          answer        |
 ------------------------------------------ 
|    dichotomy   |   2.0692214965820312   |
|    iteration   |   2.0692179892872482   |
|    newton      |   2.0692181963739746   |
 ------------------------------------------ 
```

# **Вывод**

Данное задание познакомило меня с такими методами решения, как метод дихотомии, итерации и Ньютона. Так же цель лабораторной работы достигнута, т.к мы составили программу на языке Си с процедурами решения трансцендентных алгебраических уравнений разными численными методами. При этом мы получили везде равные значения, а значит, что при решении данного уравнения мы можем использовать все из перечисленных методов.

[КП4.docx](https://github.com/CS806/kp4-IamNoobLEL/files/7829703/4.docx)
